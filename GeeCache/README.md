## Day1-缓存淘汰策略

### FIFO（First In First Out）-时间因素
- 创建一个队列，新增记录添加到队尾，每次内存不够时，淘汰队首
- 优点：实现简单
- 缺点：很多场景下，越早添加的记录越常被访问，导致某些记录被频繁添加、淘汰，缓存命中率低

### LFU（Least Frequently Used)-访问频率因素
- 淘汰缓存中访问频率最低的记录。需要维护一个按照访问次数排序的队列，淘汰时选择访问次数最少的即可
- 优点：缓存命中率高
- 缺点：维护每个记录的访问次数对内存的消耗很高；如果数据的访问模式发生变化，LFU 需要较长时间去适应

### LRU（Least Recently Used）-综合考虑时间与访问频率
- 维护一个队列，如果某条记录被访问，则移到队尾，队首是最近最少访问的数据，淘汰队首的记录
- 实现是通过 `Map + Double Linked List`：map 维护键值队映射关系，双向链表用于实现队列（将元素移动到队尾、在队尾新增记录、在队头删除记录）

## Day2-单机并发缓存
缓存值的存储和获取的逻辑：
```
                            是
接收 key --> 检查是否被缓存 -----> 返回缓存值 ⑴
                |  否                         是
                |-----> 是否应当从远程节点获取 -----> 与远程节点交互 --> 返回缓存值 ⑵
                            |  否
                            |-----> 调用`回调函数`，获取值并添加到缓存 --> 返回缓存值 ⑶
```

## Day3-HTTP 服务端

## Day4-一致性哈希