## GeeRPC 注意点

### 2022-5-5
#### 超时处理

- 客户端需要处理的超时
  1. 与服务端建立连接，导致的超时
  2. 发送请求的写超时
  3. 等待服务端处理的超时（例如服务器已挂死，迟迟不响应）
  4. 从服务端接收的读超时
- 服务端需要处理的超时
  1. 读客户端请求的读超时
  2. 处理的超时
  3. 向客户端写响应的写超时
- 在 GeeRPC 中添加了三处超时处理机制：
  1. 在客户端创建与服务端的连接时（`client.dialTimeout()`）
  2. 客户端在 `client.Call()` 统一处理整个过程产生的超时（包含客户端发送报文、等待服务端处理、客户端接收报文）
  3. 服务端处理报文时（`Server.handleRequest`）

#### 支持 HTTP 协议
- 个人理解这章做的事情就是在原先 TCP 通信的基础上，套了一层对于通过 HTTP 建立连接的支持：Client 可以通过 `CONNECT` 报文与 RPC Server 建立连接（类似于一次握手，这就是这章增加的部分），之后通信还是用的 RPC 协议（基于 HTTP 下层的 TCP 连接）；而在之前的纯 TCP 通信中，并没有这一次握手的实现，而是直接在 TCP 连接上通过 RPC 协议通信。
- 而对于 Client 来说，协议的转换是透明、无法感知的，Client 去请求调用函数仍旧像之前纯 TCP 一样，采用 `Call` 方式即可，而基于 HTTP 则可以为 Client 额外开放其他的 HTTP 服务。（即本章的 HTTP = 原先 TCP RPC + HTTP PATH 服务）
- 提供 HTTP 来建立连接的好处在于，Server 可以监听一个 TCP 端口，基于这个端口，提供对于不同 PATH 的 HTTP 服务。

### 2022-5-6

#### 负载均衡
- 如果有多个服务实例，客户端选择任意一个实例进行调用，如何选择取决于负载均衡策略。
  1. 随机选择策略
  2. 轮询算法（Round Robin）：依次调度不同的服务器，每次调度执行 `i = (i + 1) mod n`
  3. 加权轮询（Weight Round Robin）：在轮询算法的基础上，为每个服务器实例设置一个权重，高性能的机器赋予更高的权重，也可以根据服务实例的当前的负载情况做动态的调整（例如考虑近 5 分钟部署服务器的 CPU、内存消耗情况）
  4. 哈希/一致性哈希策略：根据请求的某些特征，计算一个 hash 值，根据 hash 值将请求发送到对应的机器。一致性 hash 还可以**解决服务实例动态添加情况下，调度抖动的问题**。（一个典型的应用场景是分布式缓存服务）
- 负载均衡的前提是有多个服务实例，因此需要先实现一个客户端服务发现模块 `Discovery`，它是一个接口类型，包含：
  1. `Refresh()` 从注册中心更新服务列表
  2. `Update(servers []string)` 手动更新服务列表
  3. `Get(mode SelectMode)` 根据负载均衡策略，选择一个服务实例
  4. `GetAll()` 返回所有的服务实例

#### 服务发现与注册中心
- 注册中心的好处在于，客户端和服务端都只需要感知注册中心，而不需要感知对方的存在
  ![注册中心](https://geektutu.com/post/geerpc-day7/registry.jpg)
  1. 服务端启动后，向注册中心发送注册消息，注册中心得知该服务已启动，处于可用状态；服务端还需定期向注册中心发送心跳，证明自己的可用性
  2. 客户端向注册中心询问，注册中心将当前可用的服务列表返回给客户端
  3. 客户端根据注册中心得到的服务列表，选择其中一个发起调用
- 注册中心的其他功能还有：配置的动态同步、通知机制等